{"version":3,"sources":["bird.ts","pipe.ts","game.ts"],"names":[],"mappings":"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","file":"game.459dd0b6.js","sourceRoot":"../src","sourcesContent":["import { time } from \"./types\";\n\nconst BIRD_SPEED: number = 0.25;\nconst JUMP_DURATION: number = 150;\n\nconst bird: HTMLElement = document.querySelector(\"[data-bird]\");\n\nlet timeSinceLastJump = Number.POSITIVE_INFINITY;\n\nexport function setupBird() {\n  setTop(window.innerHeight / 2);\n  document.removeEventListener(\"keydown\", handleJump);\n  document.addEventListener(\"keydown\", handleJump);\n}\n\nexport function updateBird(delta: time) {\n  const top: number = getTop();\n\n  if (timeSinceLastJump < JUMP_DURATION) {\n    setTop(top - BIRD_SPEED * delta);\n  } else {\n    setTop(top + BIRD_SPEED * delta);\n  }\n\n  timeSinceLastJump += delta;\n}\n\nexport function getBirdRect(): DOMRect {\n  return bird.getBoundingClientRect();\n}\n\nfunction setTop(top: number) {\n  bird.style.setProperty(\"--bird-top\", String(top));\n}\n\nfunction getTop(): number {\n  return parseFloat(getComputedStyle(bird).getPropertyValue(\"--bird-top\"));\n}\n\nfunction handleJump(e: KeyboardEvent) {\n  if (e.code !== \"Space\") return;\n  timeSinceLastJump = 0;\n}\n","import { Pipe, time } from \"./types\";\n\nconst HOLE_HEIGHT: number = 170;\nconst PIPE_INTERVAL: time = 1750;\nconst PIPE_SPEED: number = 0.25;\nconst PIPE_WIDTH: number = 60;\n\nlet pipes: Array<Pipe> = [];\nlet timeSinceLastPipe: time = 0;\nlet passesPipesCount: number = 0;\n\nexport function setupPipes() {\n  document.documentElement.style.setProperty(\n    \"--pipe-width\",\n    String(PIPE_WIDTH)\n  );\n  document.documentElement.style.setProperty(\n    \"--hole-height\",\n    String(HOLE_HEIGHT)\n  );\n\n  pipes.forEach((pipe) => pipe.remove());\n\n  timeSinceLastPipe = PIPE_INTERVAL;\n  passesPipesCount = 0;\n}\n\nexport function getPassedPipesCount() {\n  return passesPipesCount;\n}\n\nexport function updatePipes(delta: time) {\n  timeSinceLastPipe += delta;\n\n  if (timeSinceLastPipe > PIPE_INTERVAL) {\n    timeSinceLastPipe -= PIPE_INTERVAL;\n    createPipe();\n  }\n\n  pipes.forEach((pipe) => {\n    if (pipe.left + PIPE_WIDTH < 0) {\n      passesPipesCount++;\n      pipe.remove();\n      return;\n    }\n\n    pipe.left = pipe.left - delta * PIPE_SPEED;\n  });\n}\n\nexport function getPipeRects(): Array<DOMRect> {\n  return pipes.flatMap((pipe) => pipe.rects());\n}\n\nfunction createPipe() {\n  const pipeElement: HTMLElement = document.createElement(\"div\");\n  const topSegment: HTMLElement = createPipeSegment(\"top\");\n  const bottomSegment: HTMLElement = createPipeSegment(\"bottom\");\n\n  pipeElement.append(topSegment);\n  pipeElement.append(bottomSegment);\n\n  pipeElement.classList.add(\"pipe\");\n\n  pipeElement.style.setProperty(\n    \"--hole-top\",\n    randomNumberBetween(\n      HOLE_HEIGHT * 1.5,\n      window.innerHeight - HOLE_HEIGHT * 0.5\n    )\n  );\n\n  const pipe: Pipe = {\n    get left() {\n      return parseFloat(\n        getComputedStyle(pipeElement).getPropertyValue(\"--pipe-left\")\n      );\n    },\n    set left(value: number) {\n      pipeElement.style.setProperty(\"--pipe-left\", String(value));\n    },\n    remove() {\n      pipes = pipes.filter((p) => p !== pipe);\n      pipeElement.remove();\n    },\n    rects(): Array<DOMRect> {\n      return [\n        topSegment.getBoundingClientRect(),\n        bottomSegment.getBoundingClientRect(),\n      ];\n    },\n  };\n\n  pipe.left = window.innerWidth;\n  document.body.append(pipeElement);\n  pipes.push(pipe);\n}\n\nfunction createPipeSegment(position): HTMLElement {\n  const segment: HTMLElement = document.createElement(\"div\");\n  segment.classList.add(\"segment\", position);\n  return segment;\n}\n\nfunction randomNumberBetween(min: number, max: number): string {\n  return String(Math.floor(Math.random() * (max - min + 1)) + min);\n}\n","import { time } from \"./types\";\nimport { setupBird, updateBird, getBirdRect } from \"./bird\";\nimport {\n  getPassedPipesCount,\n  getPipeRects,\n  setupPipes,\n  updatePipes,\n} from \"./pipe\";\n\ndocument.addEventListener(\"keypress\", handleStart, { once: true });\n\nconst title: HTMLElement = document.querySelector(\"[data-title]\");\nconst subTitle: HTMLElement = document.querySelector(\"[data-subtitle]\");\n\nlet lastTime: time = null;\n\nfunction handleStart() {\n  lastTime = null;\n  title.classList.add(\"hidden\");\n  setupBird();\n  setupPipes();\n  window.requestAnimationFrame(updateLoop);\n}\n\nfunction updateLoop(time: time) {\n  if (lastTime === null) {\n    lastTime = time;\n    window.requestAnimationFrame(updateLoop);\n    return;\n  }\n\n  const delta: time = time - lastTime;\n\n  if (checkLose()) {\n    handleLose();\n    return;\n  }\n\n  updateBird(delta);\n  updatePipes(delta);\n\n  lastTime = time;\n  window.requestAnimationFrame(updateLoop);\n}\n\nfunction checkLose(): boolean {\n  const birdRect: DOMRect = getBirdRect();\n  const isInsidePipe = getPipeRects().some((rect) =>\n    isColliding(birdRect, rect)\n  );\n  const isOutsideWorld =\n    birdRect.top < 0 || birdRect.bottom > window.innerHeight;\n\n  return isInsidePipe || isOutsideWorld;\n}\n\nfunction handleLose() {\n  setTimeout(() => {\n    let rects: Array<DOMRect> = getPipeRects();\n    console.log({ rects });\n    title.classList.remove(\"hidden\");\n    subTitle.classList.remove(\"hidden\");\n    subTitle.textContent = `${getPassedPipesCount()} PIPES PASSED !!`;\n    document.addEventListener(\"keypress\", handleStart, { once: true });\n  }, 200);\n}\n\nfunction isColliding(rectOne: DOMRect, rectTwo: DOMRect): boolean {\n  return (\n    rectOne.left < rectTwo.right &&\n    rectOne.top < rectTwo.bottom &&\n    rectOne.right > rectTwo.left &&\n    rectOne.bottom > rectTwo.top\n  );\n}\n"]}